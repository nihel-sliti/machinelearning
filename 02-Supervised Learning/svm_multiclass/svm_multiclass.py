# -*- coding: utf-8 -*-
"""Svm-multiclass.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wQj6eJHWCpV9Qt4NmktjPM381mG31P6O
"""

from sklearn import svm
from sklearn import datasets
import numpy as np
import matplotlib.pyplot as plt

iris = datasets.load_iris()

x= iris.data
y = iris.target

from sklearn.model_selection import train_test_split
x_train1, x_test1, y_train1, y_test1 = train_test_split(x, y, test_size=0.33, random_state=0)

model = svm.SVC(kernel='rbf', gamma= 0.1, C=1, decision_function_shape='ovr')

model.fit(x_train1, y_train1)

pred=model.predict(x_test1)
print(pred)

from sklearn.metrics import accuracy_score
Acc = accuracy_score(y_test1,pred)*100
print("Accuracy : %f" % (Acc))

# Créer une grille de points pour dessiner les frontières de décision
x_min, x_max = x[:, 0].min() - 1, x[:, 0].max() + 1
y_min, y_max = x[:, 1].min() - 1, x[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.02),
                     np.arange(y_min, y_max, 0.02))
# Ajouter deux colonnes de zéros pour correspondre aux 4 dimensions attendues
grid_points = np.c_[xx.ravel(), yy.ravel(), np.zeros((xx.ravel().shape[0], 2))]

# Prédire les classes pour chaque point de la grille
Z = model.predict(grid_points)
Z = Z.reshape(xx.shape)

# Afficher les frontières de décision
plt.figure(figsize=(10, 6))
plt.contourf(xx, yy, Z, alpha=0.8, cmap=plt.cm.Paired)

# Afficher les points de données
plt.scatter(x[:, 0], x[:, 1], c=y, edgecolors='k', cmap=plt.cm.Paired)
plt.xlabel('Longueur du sépale')
plt.ylabel('Largeur du sépale')
plt.title('Frontières de décision SVM avec Dataset Iris (Multiclasse)')
plt.show()

model = svm.SVC(kernel='rbf', gamma= 0.1, C=1, decision_function_shape='ovo')
model.fit(x_train1, y_train1)
pred=model.predict(x_test1)
print(pred)

from sklearn.metrics import accuracy_score
Acc = accuracy_score(y_test1,pred)*100
print("Accuracy : %f" % (Acc))